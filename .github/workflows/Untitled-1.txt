// server.js
const express = require('express');
const multer = require('multer');
const Tesseract = require('tesseract.js');
const app = express();
const port = 3000;

// Configuration de multer pour gérer les uploads d'images
const upload = multer({ dest: 'uploads/' });

// Middleware pour parser le JSON
app.use(express.json());

/**
 * Endpoint pour scanner une facture via OCR.
 * Expects: un fichier image uploadé sous le champ "invoiceImage".
 */
app.post('/api/scan-invoice', upload.single('invoiceImage'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'Aucun fichier téléchargé.' });
  }

  // Utilisation de Tesseract.js pour extraire le texte de l'image
  Tesseract.recognize(
    req.file.path,
    'eng', // ou 'fra' pour le français, selon la langue de vos factures
    { logger: m => console.log(m) }
  )
    .then(({ data: { text } }) => {
      // Exemple de traitement pour extraire un numéro de facture
      const invoiceDetails = parseInvoiceText(text);
      res.json({ ocrText: text, invoiceDetails });
    })
    .catch(err => {
      console.error(err);
      res.status(500).json({ error: 'Erreur lors du traitement OCR.' });
    });
});

/**
 * Fonction simple pour extraire des informations d'une facture.
 * (À améliorer avec des expressions régulières ou du NLP selon le format de vos factures)
 */
function parseInvoiceText(text) {
  const invoiceNumberMatch = text.match(/Invoice\s*#:\s*(\w+)/i);
  const invoiceNumber = invoiceNumberMatch ? invoiceNumberMatch[1] : 'Inconnu';
  return { invoiceNumber };
}

/**
 * Endpoint pour vérifier et comparer les bons de livraison.
 * On attend dans le body deux tableaux : deliveredItems et expectedItems.
 */
app.post('/api/verify-delivery', (req, res) => {
  const { deliveredItems, expectedItems } = req.body;
  if (!Array.isArray(deliveredItems) || !Array.isArray(expectedItems)) {
    return res.status(400).json({ error: 'Format de données invalide.' });
  }
  // Comparaison pour identifier les articles manquants
  const missingItems = expectedItems.filter(item => !deliveredItems.includes(item));
  res.json({ missingItems });
});

/**
 * Gestion simple des stocks en mémoire.
 */
let stock = [
  { id: 1, product: 'Produit A', quantity: 100 },
  { id: 2, product: 'Produit B', quantity: 200 },
];

/**
 * Endpoint pour récupérer l'état des stocks.
 */
app.get('/api/stock', (req, res) => {
  res.json(stock);
});

/**
 * Endpoint pour mettre à jour le stock d'un produit.
 * Expects: { id: Number, quantity: Number } dans le body.
 */
app.post('/api/stock/update', (req, res) => {
  const { id, quantity } = req.body;
  let product = stock.find(item => item.id === id);
  if (!product) {
    return res.status(404).json({ error: 'Produit non trouvé.' });
  }
  product.quantity = quantity;
  res.json({ message: 'Stock mis à jour', product });
});

/**
 * Endpoint pour planifier une relance.
 * Ici, on se contente de simuler la planification (dans une vraie application, vous utiliserez un planificateur de tâches).
 */
app.post('/api/reminder', (req, res) => {
  const { message, date } = req.body;
  console.log(`Relance planifiée: "${message}" pour le ${date}`);
  res.json({ message: 'Relance planifiée' });
});

app.listen(port, () => {
  console.log(`Serveur lancé sur http://localhost:${port}`);
});
