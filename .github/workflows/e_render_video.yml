name: e_render_video

on:
  workflow_call:
    inputs:
      target_res:
        required: true
        type: string             # ex: "720x1280"
      fps:
        required: true
        type: number             # ex: 30
      min_duration_sec:
        required: true
        type: number             # ex: 65
      max_duration_sec:
        required: true
        type: number             # ex: 75
      captions_path:
        required: true
        type: string             # ex: outputs/subtitles.srt
      voice_path:
        required: true
        type: string             # ex: outputs/voice.mp3
      mute_stock_clips:
        required: true
        type: boolean
      subtitles_fontsize:
        required: true
        type: number
      subtitles_margin_v:
        required: true
        type: number
      music_url:
        required: false
        type: string             # Optionnel: URL d'une musique libre de droits
    outputs:
      video_path:
        description: "Chemin de la vidéo finale"
        value: ${{ jobs.render.outputs.video_path }}

permissions:
  contents: read

jobs:
  render:
    runs-on: ubuntu-latest
    outputs:
      video_path: ${{ steps.meta.outputs.video_path }}
    steps:
      - uses: actions/checkout@v4

      # Artifacts requis
      - name: Télécharger images (dossier)
        uses: actions/download-artifact@v4
        with:
          name: images_dir
          path: work/images

      - name: Télécharger audio (voix)
        uses: actions/download-artifact@v4
        with:
          name: voice_mp3
          path: outputs

      - name: Télécharger SRT
        uses: actions/download-artifact@v4
        with:
          name: subtitles_srt
          path: outputs

      # (Optionnel) Télécharger musique si fournie
      - name: Télécharger musique (optionnel)
        if: ${{ inputs.music_url != '' }}
        run: |
          sudo apt-get update && sudo apt-get install -y curl
          mkdir -p outputs
          curl -L --fail -o outputs/music.mp3 "${{ inputs.music_url }}"

      - name: Installer FFmpeg + outils
        run: sudo apt-get update && sudo apt-get install -y ffmpeg coreutils jq findutils

      - name: Vérifier médias
        run: |
          echo "== IMAGES ==" && find work/images -maxdepth 1 -type f | sort || true
          echo "== VOIX ==" && ls -l outputs/voice.mp3
          echo "== SRT ==" && ls -l outputs/subtitles.srt || true
          [ -f outputs/music.mp3 ] && echo "== MUSIC ==" && ls -l outputs/music.mp3 || true

      - name: Construire slideshow 9:16 à la bonne durée (corrigé)
        env:
          RES:  ${{ inputs.target_res }}
          FPS:  ${{ inputs.fps }}
          MIN:  ${{ inputs.min_duration_sec }}
          MAX:  ${{ inputs.max_duration_sec }}
        run: |
          set -euo pipefail
          mkdir -p work build outputs

          # Parse résolution
          W="${RES%x*}"; H="${RES#*x}"

          # Lister images source
          mapfile -t SRC < <(find work/images -maxdepth 1 -type f \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' \) | sort)
          if [ "${#SRC[@]}" -eq 0 ]; then
            echo "Aucune image trouvée dans work/images"; exit 1
          fi

          # Normaliser en 9:16 (scale+pad) -> build/0001.png, 0002.png...
          i=0
          for f in "${SRC[@]}"; do
            i=$((i+1))
            printf -v OUT "build/%04d.png" "$i"
            # -frames:v 1 -update 1 pour éviter l'erreur image2 sur certains builds
            ffmpeg -y -i "$f" -vf "scale='if(gt(a,$W/$H),$W,-1)':'if(gt(a,$W/$H),-1,$H)',pad=$W:$H:(ow-iw)/2:(oh-ih)/2" -frames:v 1 -update 1 "$OUT"
          done

          echo "== DEBUG images normalisées ==" && ls -l build | sed -n '1,20p'

          # Durée audio -> cible de durée
          if [ -f "outputs/voice.mp3" ]; then
            ASEC=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 "outputs/voice.mp3" | awk '{printf("%.0f",$1)}')
          else
            ASEC=0
          fi
          [ -z "${ASEC:-}" ] && ASEC=0

          TGT="$MIN"
          if [ "$ASEC" -gt "$TGT" ]; then TGT="$ASEC"; fi
          if [ "$TGT" -gt "$MAX" ]; then TGT="$MAX"; fi
          echo "Durée audio=${ASEC}s, cible=${TGT}s"

          # Durée par image
          N=$(ls build/*.png | wc -l)
          if [ "$N" -lt 1 ]; then echo "Pas d'images normalisées dans build/"; exit 1; fi
          per=$(awk -v T="$TGT" -v N="$N" 'BEGIN{d=T/N; if(d<1.5)d=1.5; if(d>5)d=5; printf("%.2f",d)}')
          echo "Durée par image=${per}s (N=${N})"

          # filelist avec chemins ABSOLUS (évite build/build/xxx.png)
          FL="build/filelist.txt"
          : > "$FL"
          find "$(pwd)/build" -maxdepth 1 -type f -name "*.png" | sort | while read -r f; do
            echo "file '$f'" >> "$FL"
            echo "duration $per" >> "$FL"
          done
          last=$(find "$(pwd)/build" -maxdepth 1 -type f -name "*.png" | sort | tail -n 1)
          echo "file '$last'" >> "$FL"

          echo "=== filelist.txt ==="
          sed -n '1,30p' "$FL"

          # Construire le slideshow
          ffmpeg -y -f concat -safe 0 -i "$FL" -vsync vfr -pix_fmt yuv420p -r "$FPS" "work/slideshow.mp4"

          # Adapter à la durée cible (padding/troncature)
          CUR=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 "work/slideshow.mp4")
          needpad=$(awk -v cur="$CUR" -v tgt="$TGT" 'BEGIN{if(cur<tgt)print 1; else print 0}')
          if [ "$needpad" -eq 1 ]; then
            padsec=$(awk -v cur="$CUR" -v tgt="$TGT" 'BEGIN{d=tgt-cur; if(d<0)d=0; printf("%.2f",d)}')
            ffmpeg -y -i work/slideshow.mp4 -vf "tpad=stop_mode=clone:stop_duration=${padsec}" -r "$FPS" work/slideshow_padded.mp4
            mv work/slideshow_padded.mp4 work/slideshow.mp4
          fi
          ffmpeg -y -i work/slideshow.mp4 -t "$TGT" -c:v libx264 -pix_fmt yuv420p work/slideshow_trim.mp4
          mv work/slideshow_trim.mp4 work/slideshow.mp4

      - name: Mixer audio (voix + musique optionnelle)
        run: |
          set -euo pipefail
          if [ -f "outputs/music.mp3" ]; then
            ffmpeg -y -i work/slideshow.mp4 -i outputs/voice.mp3 -i outputs/music.mp3 \
              -filter_complex "[1:a]volume=1.0[a1];[2:a]volume=0.25[a2];[a1][a2]amix=inputs=2:normalize=0[aout]" \
              -map 0:v -map "[aout]" -c:v copy -c:a aac -shortest work/with_audio.mp4
          else
            ffmpeg -y -i work/slideshow.mp4 -i outputs/voice.mp3 -map 0:v -map 1:a -c:v copy -c:a aac -shortest work/with_audio.mp4
          fi

      - name: Appliquer sous-titres stylés
        env:
          FS: ${{ inputs.subtitles_fontsize }}
          MV: ${{ inputs.subtitles_margin_v }}
        run: |
          set -euo pipefail
          if [ -f "outputs/subtitles.srt" ]; then
            ffmpeg -y -i work/with_audio.mp4 \
              -vf "subtitles=outputs/subtitles.srt:force_style='Fontname=DejaVu Sans,Fontsize=${FS},Outline=2,Shadow=1,Alignment=5,MarginV=${MV}'" \
              -c:a copy outputs/final.mp4
          else
            echo "Aucun SRT trouvé, sortie sans sous-titres"
            cp work/with_audio.mp4 outputs/final.mp4
          fi

      - name: Publier vidéo
        uses: actions/upload-artifact@v4
        with:
          name: final_video_mp4
          path: outputs/final.mp4
          if-no-files-found: error
          retention-days: 7

      - id: meta
        run: echo "video_path=outputs/final.mp4" >> "$GITHUB_OUTPUT"