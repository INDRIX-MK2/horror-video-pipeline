name: E - Render Final Video
on:
  workflow_call:
    inputs:
      fps:
        description: "Images par seconde"
        required: true
        type: string

jobs:
  render:
    runs-on: ubuntu-latest
    env:
      FPS: ${{ inputs.fps }}

    steps:
      - name: Download selected media
        uses: actions/download-artifact@v4
        with:
          name: selected_media
          path: work/sel

      - name: Download voice
        uses: actions/download-artifact@v4
        with:
          name: voice
          path: work

      - name: Download subtitles
        uses: actions/download-artifact@v4
        with:
          name: subtitles
          path: work

      - name: Install ffmpeg
        shell: bash
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Normalize sources (images → clips ; videos → trim/scale)
        shell: bash
        run: |
          set -e
          mkdir -p norm
          img_dur=4
          idx=0

          # Images -> segments ~4s
          if [ -d "work/sel/images" ]; then
            find work/sel/images -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' \) | sort | while read -r f; do
              ffmpeg -nostdin -v error -loop 1 -t "${img_dur}" -i "$f" \
                -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${FPS}" \
                -pix_fmt yuv420p -c:v libx264 -preset veryfast -crf 20 "norm/seg_${idx}.mp4"
              idx=$((idx+1))
            done
          fi

          # Vidéos -> tronquées à 4s, même échelle/FPS
          if [ -d "work/sel/videos" ]; then
            find work/sel/videos -type f -iname '*.mp4' | sort | while read -r f; do
              ffmpeg -nostdin -v error -y -i "$f" -t 4 \
                -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${FPS}" \
                -pix_fmt yuv420p -c:v libx264 -preset veryfast -crf 20 "norm/seg_${idx}.mp4"
              idx=$((idx+1))
            done
          fi

          # Fallback si aucun média
          if [ ! -e "norm/seg_0.mp4" ]; then
            ffmpeg -nostdin -v error -f lavfi -i "color=size=1080x1920:rate=${FPS}:color=black" -t 8 -pix_fmt yuv420p "norm/seg_0.mp4"
          fi

      - name: Write build_xfade.py (no heredoc)
        shell: bash
        run: |
          set -e
          {
            echo "import glob, pathlib"
            echo "segs = sorted(glob.glob('norm/seg_*.mp4'))"
            echo "n = len(segs)"
            echo "inputs = ' '.join([f'-i {s}' for s in segs])"
            echo "pathlib.Path('inputs.txt').write_text(inputs, encoding='utf-8')"
            echo "# Build filtergraph: setpts + xfade chain"
            echo "labels = []"
            echo "for i in range(n):"
            echo "    labels.append(f'[{i}:v]setpts=PTS-STARTPTS[v{i}]')"
            echo "dur = 1.0"
            echo "offset = 3.0  # segments ~4s -> crossfade à 3s"
            echo "if n == 1:"
            echo "    chain = ''"
            echo "    out_label = '[v0]'"
            echo "else:"
            echo "    chain_parts = []"
            echo "    prev = '[v0]'"
            echo "    for i in range(1, n):"
            echo "        cur = f'[v{i}]'"
            echo "        out = f'[vx{i}]'"
            echo "        chain_parts.append(f'{prev}{cur}xfade=transition=fade:duration={dur}:offset={offset}{out}')"
            echo "        prev = out"
            echo "    chain = ';'.join(chain_parts)"
            echo "    out_label = prev"
            echo "# Assemble filters (video chain only). Subtitles added later."
            echo "fg = ';'.join(labels)"
            echo "if chain:"
            echo "    fg = fg + ';' + chain"
            echo "pathlib.Path('chain_label.txt').write_text(out_label, encoding='utf-8')"
            echo "pathlib.Path('video_chain.txt').write_text(fg, encoding='utf-8')"
          } > build_xfade.py
          python build_xfade.py

      - name: Generate filters.txt (append subtitles on chain output)
        shell: bash
        run: |
          set -e
          VCHAIN=$(cat video_chain.txt)
          OUTLBL=$(cat chain_label.txt)  # ex: [v0] ou [vxN]
          : > filters.txt
          echo "${VCHAIN};" >> filters.txt
          echo "${OUTLBL}subtitles=work/captions.ass:force_style=Fontname=Arial,Fontsize=14,PrimaryColour=&H00FFFF00,Outline=2,Shadow=1,Alignment=2[vout]" >> filters.txt
          sed -n '1,200p' filters.txt

      - name: Render final.mp4 (video xfade + voice + karaoke)
        shell: bash
        run: |
          set -e
          mkdir -p outputs
          INP=$(cat inputs.txt)
          # Nombre d'inputs vidéo (N) pour indexer correctement l'audio (N = index de work/voice.mp3)
          N=$(printf "%s\n" "$INP" | grep -o '\-i norm/seg_[0-9]\+\.mp4' | wc -l)
          # Toutes les vidéos + l'audio en dernier
          bash -lc "ffmpeg -nostdin -v error $INP -i work/voice.mp3 -filter_complex_script filters.txt -map '[vout]' -map ${N}:a -r ${FPS} -pix_fmt yuv420p -c:v libx264 -crf 18 -preset veryfast -c:a aac -b:a 192k -shortest outputs/final.mp4"

      - name: Upload final video
        uses: actions/upload-artifact@v4
        with:
          name: final_video
          path: outputs/final.mp4