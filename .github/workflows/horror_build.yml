name: Horror Build

on:
  workflow_dispatch:
    inputs:
      clips_count:
        description: "Nombre de clips à utiliser"
        required: true
        default: "13"
      out_name:
        description: "Nom du fichier vidéo final"
        required: true
        default: "final_horror.mp4"

env:
  CLIPS_COUNT: ${{ inputs.clips_count }}
  OUT_NAME: ${{ inputs.out_name }}
  # Secrets
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  MANIFEST_URL: ${{ secrets.MANIFEST_URL_HORROR }}

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools (ffmpeg, jq, curl)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get -y update
          sudo apt-get -y install ffmpeg jq curl coreutils

      # ---------- STORY ----------
      - name: Generate story (OpenAI)
        shell: bash
        run: |
          set -euo pipefail
          : "${OPENAI_API_KEY:?OPENAI_API_KEY is not set}"
          mkdir -p story

          SYS="Tu écris un script court et immersif d'horreur en français."
          USER="Écris un script TikTok de 180 à 200 mots (65-75s). Structure : hook (10s), développement (45s), conclusion avec CTA (10s). Thème : horreur atmosphérique, manoir, pluie, bruits métalliques. Style concis, phrases courtes, sans grossièretés."

          jq -n \
            --arg sys "$SYS" \
            --arg user "$USER" \
            '{model:"gpt-4o-mini",temperature:1,
              messages:[{role:"system",content:$sys},{role:"user",content:$user}]}' \
            > story/payload.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @story/payload.json \
          | jq -r '.choices[0].message.content' > story/story.txt

          if [ ! -s story/story.txt ]; then
            echo "OpenAI returned an empty story." >&2
            exit 1
          fi

      - name: Upload story
        uses: actions/upload-artifact@v4
        with:
          name: story
          path: story/story.txt

      # ---------- VOICE ----------
      - name: Generate voice (OpenAI TTS)
        shell: bash
        run: |
          set -euo pipefail
          : "${OPENAI_API_KEY:?OPENAI_API_KEY is not set}"
          mkdir -p voice

          TEXT="$(tr '\n' ' ' < story/story.txt | sed 's/  \+/ /g')"

          # Construit le JSON proprement puis envoie à l'API (sortie binaire -> -o)
          jq -n --arg input "$TEXT" \
            '{model:"gpt-4o-mini-tts", voice:"alloy", input:$input}' \
            > voice/tts_payload.json

          curl -s -X POST https://api.openai.com/v1/audio/speech \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @voice/tts_payload.json \
            -o voice/voice.mp3

          if [ ! -s voice/voice.mp3 ]; then
            echo "OpenAI TTS returned no audio." >&2
            exit 1
          fi

      - name: Upload voice
        uses: actions/upload-artifact@v4
        with:
          name: voice
          path: voice/voice.mp3

      # ---------- CLIPS : SELECT + DOWNLOAD + RE-ENCODE ----------
      - name: Select clips from manifest and re-encode (1080x1920/30fps)
        shell: bash
        run: |
          set -euo pipefail
          : "${MANIFEST_URL:?MANIFEST_URL is not set}"
          : "${CLIPS_COUNT:?CLIPS_COUNT is not set}"

          mkdir -p selected_media
          # Récupère le manifest (une URL par ligne)
          curl -fsSL "${MANIFEST_URL}" -o selected_media/manifest_urls.txt

          # Nettoie et filtre les lignes non vides
          awk 'NF' selected_media/manifest_urls.txt > selected_media/manifest.clean.txt

          TOTAL="$(wc -l < selected_media/manifest.clean.txt | tr -d ' ')"
          if [ "${TOTAL}" -lt "${CLIPS_COUNT}" ]; then
            echo "Manifest has only ${TOTAL} urls, need ${CLIPS_COUNT}." >&2
            exit 1
          fi

          # Shuffle + sélection
          shuf selected_media/manifest.clean.txt | head -n "${CLIPS_COUNT}" > selected_media/selection.txt

          # Téléchargement + ré-encodage + génération liste concat
          rm -f selected_media/list.txt
          idx=0
          while IFS= read -r URL; do
            idx=$((idx+1))
            SRC="selected_media/src_${idx}.mp4"
            OUT="selected_media/seg_${idx}.mp4"

            # Télécharge le clip
            curl -fsSL -L "${URL}" -o "${SRC}"

            # Ré-encode au bon format portrait
            ffmpeg -nostdin -y -i "${SRC}" \
              -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1" \
              -r 30 -c:v libx264 -crf 18 -pix_fmt yuv420p -an "${OUT}"

            # Alimente le fichier concat
            printf "file '%s'\n" "${OUT}" >> selected_media/list.txt
          done < selected_media/selection.txt

          # Concaténation sans ré-encodage
          ffmpeg -nostdin -y -f concat -safe 0 -i selected_media/list.txt -c copy selected_media/temp_merge.mp4

      - name: Upload selected_media
        uses: actions/upload-artifact@v4
        with:
          name: selected_media
          path: selected_media/

      # ---------- FINAL RENDER (mix voice over) ----------
      - name: Render final video (mix voice)
        shell: bash
        run: |
          set -euo pipefail
          : "${OUT_NAME:?OUT_NAME is not set}"
          mkdir -p out

          # Mixe la voix en unique piste audio (vol=1.0). Vidéo : copie (déjà en h264 yuv420p)
          # On re-muxe en libx264 pour garantir compatibilité, et -shortest.
          ffmpeg -nostdin -y \
            -i selected_media/temp_merge.mp4 \
            -i voice/voice.mp3 \
            -filter_complex "[1:a]volume=1.0[a1];[0:v]format=yuv420p[v]" \
            -map "[v]" -map "[a1]" \
            -c:v libx264 -preset veryfast -crf 18 \
            -c:a aac -b:a 192k -shortest "out/${OUT_NAME}"

          if [ ! -s "out/${OUT_NAME}" ]; then
            echo "Final video not produced." >&2
            exit 1
          fi

      - name: Upload final_video
        uses: actions/upload-artifact@v4
        with:
          name: final_video
          path: out/