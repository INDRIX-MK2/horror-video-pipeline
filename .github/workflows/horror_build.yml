name: Horror Video Pipeline (Dropbox, no-jq, no-heredoc)

on:
  workflow_dispatch:
    inputs:
      clips_count:
        description: "Nombre de clips à assembler"
        required: false
        default: "13"
      out_name:
        description: "Nom du fichier de sortie"
        required: false
        default: "final_horror.mp4"

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
      ELEVENLABS_VOICE_ID: ${{ secrets.ELEVENLABS_VOICE_ID }}
      MANIFEST_URL: ${{ secrets.MANIFEST_URL }}
      DROPBOX_ACCESS_TOKEN: ${{ secrets.DROPBOX_ACCESS_TOKEN }}
      CLIPS_COUNT: ${{ github.event.inputs.clips_count || '13' }}
      OUT_NAME: ${{ github.event.inputs.out_name || 'final_horror.mp4' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required secrets
        shell: bash
        run: |
          set -euo pipefail
          miss=()
          for v in OPENAI_API_KEY ELEVENLABS_API_KEY ELEVENLABS_VOICE_ID MANIFEST_URL DROPBOX_ACCESS_TOKEN; do
            if [ -z "${!v:-}" ]; then miss+=("$v"); fi
          done
          if [ "${#miss[@]}" -gt 0 ]; then
            echo "Secrets manquants: ${miss[*]}"
            exit 1
          fi

      - name: Install tools
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg python3

      # ---------- Story (OpenAI) ----------
      - name: Generate story (OpenAI) - build payload script
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p story scripts
          printf '%s\n' "import json, os, sys" > scripts/mk_openai_payload.py
          printf '%s\n' "sys_text = os.environ.get('SYS','')" >> scripts/mk_openai_payload.py
          printf '%s\n' "user_text = os.environ.get('USER_PROMPT','')" >> scripts/mk_openai_payload.py
          printf '%s\n' "payload={" >> scripts/mk_openai_payload.py
          printf '%s\n' "  \"model\":\"gpt-4o-mini\"," >> scripts/mk_openai_payload.py
          printf '%s\n' "  \"temperature\":1," >> scripts/mk_openai_payload.py
          printf '%s\n' "  \"messages\":[{\"role\":\"system\",\"content\":sys_text},{\"role\":\"user\",\"content\":user_text}]" >> scripts/mk_openai_payload.py
          printf '%s\n' "}" >> scripts/mk_openai_payload.py
          printf '%s\n' "json.dump(payload, sys.stdout, ensure_ascii=False)" >> scripts/mk_openai_payload.py

          printf '%s\n' "import json, sys" > scripts/extract_openai_text.py
          printf '%s\n' "data=json.load(open(sys.argv[1],'r',encoding='utf-8'))" >> scripts/extract_openai_text.py
          printf '%s\n' "print(data['choices'][0]['message']['content'])" >> scripts/extract_openai_text.py

      - name: Generate story (OpenAI) - call API
        shell: bash
        run: |
          set -euo pipefail
          # On place les textes ici (plus d'env YAML piégeux)
          SYS="Tu écris un script court et immersif d'horreur en français."
          USER_PROMPT="Écris un script TikTok de 180 à 200 mots (65-75s). Structure : hook (10s), développement (45s), conclusion avec CTA (10s). Thème : horreur atmosphérique, manoir, pluie, bruits métalliques. Style concis, phrases courtes, sans grossièretés."

          mkdir -p story
          SYS="$SYS" USER_PROMPT="$USER_PROMPT" python3 scripts/mk_openai_payload.py > story/payload.json

          HTTP_CODE=$(curl -sS -o story/resp.json -w "%{http_code}" \
            https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            --data-binary @story/payload.json)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "OpenAI HTTP $HTTP_CODE"
            head -c 500 story/resp.json || true
            exit 1
          fi

          python3 scripts/extract_openai_text.py story/resp.json > story/story.txt
          if [ ! -s story/story.txt ]; then echo "Story vide"; exit 1; fi

      # ---------- Ingest clips ----------
      - name: Download manifest & clips
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p bank_video/Horreur selected_media
          curl -sSL "$MANIFEST_URL" -o selected_media/manifest_urls.txt
          awk 'NF' selected_media/manifest_urls.txt > selected_media/urls.txt

          mapfile -t URLS < selected_media/urls.txt
          if [ "${#URLS[@]}" -eq 0 ]; then echo "Aucune URL dans le manifest"; exit 1; fi

          printf '%s\n' "${URLS[@]}" | shuf > selected_media/urls_shuf.txt
          mapfile -t SEL < <(head -n "$CLIPS_COUNT" selected_media/urls_shuf.txt)

          : > selected_media/manifest.txt
          idx=0
          for u in "${SEL[@]}"; do
            idx=$((idx+1))
            nm=$(printf 'clip_%02d.mp4' "$idx")
            dest="bank_video/Horreur/$nm"
            curl -L --fail --retry 3 --retry-all-errors -o "$dest" "$u"
            printf '%s\n' "$dest" >> selected_media/manifest.txt
          done

      # ---------- Normalize + concat ----------
      - name: Normalize clips and concat (1080x1920/30fps + effets)
        shell: bash
        run: |
          set -euo pipefail
          rm -f selected_media/list.txt
          i=0
          while IFS= read -r SRC; do
            [ -n "$SRC" ] || continue
            i=$((i+1))
            OUT="selected_media/seg_${i}.mp4"
            ffmpeg -nostdin -y -i "$SRC" \
              -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,eq=contrast=1.08:brightness=0.02:saturation=1.05,vignette,noise=alls=10:allf=t+u" \
              -r 30 -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -an "$OUT"
            printf "file '%s'\n" "seg_${i}.mp4" >> selected_media/list.txt
          done < selected_media/manifest.txt

          ( cd selected_media && ffmpeg -nostdin -y -f concat -safe 0 -i list.txt -c copy merged.mp4 )

      # ---------- TTS (ElevenLabs) ----------
      - name: Generate voiceover (ElevenLabs)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p audio scripts
          TEXT=$(tr '\n' ' ' < story/story.txt | sed 's/  */ /g' | sed 's/"/\\"/g')

          printf '%s\n' "import json, os, sys" > scripts/mk_eleven_payload.py
          printf '%s\n' "text=os.environ.get('TTS_TEXT','')" >> scripts/mk_eleven_payload.py
          printf '%s\n' "payload={\"text\":text,\"model_id\":\"eleven_multilingual_v2\",\"voice_settings\":{\"stability\":0.4,\"similarity_boost\":0.8}}" >> scripts/mk_eleven_payload.py
          printf '%s\n' "json.dump(payload, sys.stdout, ensure_ascii=False)" >> scripts/mk_eleven_payload.py

          TTS_TEXT="$TEXT" python3 scripts/mk_eleven_payload.py > audio/tts_payload.json

          curl -sS -X POST "https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}" \
            -H "xi-api-key: ${ELEVENLABS_API_KEY}" \
            -H "Content-Type: application/json" \
            --data-binary @audio/tts_payload.json \
            --output audio/voice.mp3

          ffmpeg -nostdin -y -i audio/voice.mp3 -ar 44100 -ac 2 audio/voice.wav
          ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 audio/voice.wav > audio/voice_duration.txt

      # ---------- Subtitles (.ass) ----------
      - name: Build subtitles (.ass)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p subtitles

          printf '%s\n' "[Script Info]" > subtitles/captions.ass
          printf '%s\n' "ScriptType: v4.00+" >> subtitles/captions.ass
          printf '%s\n' "PlayResX: 1080" >> subtitles/captions.ass
          printf '%s\n' "PlayResY: 1920" >> subtitles/captions.ass
          printf '%s\n' "Timer: 100.0000" >> subtitles/captions.ass
          printf '\n' >> subtitles/captions.ass
          printf '%s\n' "[V4+ Styles]" >> subtitles/captions.ass
          printf '%s\n' "Format: Name,Fontname,Fontsize,PrimaryColour,SecondaryColour,OutlineColour,BackColour,Bold,Italic,Underline,StrikeOut,ScaleX,ScaleY,Spacing,Angle,BorderStyle,Outline,Shadow,Alignment,MarginL,MarginR,MarginV,Encoding" >> subtitles/captions.ass
          printf '%s\n' "Style: TikTok,Montserrat SemiBold,56,&H00FFFFFF,&H00FFFFFF,&H00222222,&H66000000,-1,0,0,0,100,100,0,0,1,3,0,2,50,50,60,1" >> subtitles/captions.ass
          printf '\n' >> subtitles/captions.ass
          printf '%s\n' "[Events]" >> subtitles/captions.ass
          printf '%s\n' "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text" >> subtitles/captions.ass

          printf '%s\n' "import sys" > subtitles/build_ass.py
          printf '%s\n' "dur=float(sys.argv[1])" >> subtitles/build_ass.py
          printf '%s\n' "txt=open('story/story.txt','r',encoding='utf-8').read().strip().replace('\n',' ')" >> subtitles/build_ass.py
          printf '%s\n' "words=txt.split()" >> subtitles/build_ass.py
          printf '%s\n' "n=len(words)" >> subtitles/build_ass.py
          printf '%s\n' "per=max(dur/max(n/5,1), 2.0)" >> subtitles/build_ass.py
          printf '%s\n' "t=0.0; acc=0.0; buf=[]; lines=[]" >> subtitles/build_ass.py
          printf '%s\n' "def ts(x):" >> subtitles/build_ass.py
          printf '%s\n' "    m=int(x//60); s=int(x%60); cs=int(round((x-m*60-s)*100))" >> subtitles/build_ass.py
          printf '%s\n' "    return f'{m:d}:{s:02d}:{cs:02d}.00'" >> subtitles/build_ass.py
          printf '%s\n' "for w in words:" >> subtitles/build_ass.py
          printf '%s\n' "    buf.append(w); acc+=per" >> subtitles/build_ass.py
          printf '%s\n' "    if acc>=2.8:" >> subtitles/build_ass.py
          printf '%s\n' "        start=t; end=min(t+acc, dur)" >> subtitles/build_ass.py
          printf '%s\n' "        lines.append((start,end,' '.join(buf))); t=end; buf=[]; acc=0.0" >> subtitles/build_ass.py
          printf '%s\n' "if buf:" >> subtitles/build_ass.py
          printf '%s\n' "    start=t; end=min(t+(acc if acc>0 else 2.0), dur)" >> subtitles/build_ass.py
          printf '%s\n' "    lines.append((start,end,' '.join(buf)))" >> subtitles/build_ass.py
          printf '%s\n' "with open('subtitles/captions.ass','a',encoding='utf-8') as f:" >> subtitles/build_ass.py
          printf '%s\n' "    for s,e,text in lines:" >> subtitles/build_ass.py
          printf '%s\n' "        print(f'Dialogue: 0,{ts(s)},{ts(e)},TikTok,,0,0,0,,{text}', file=f)" >> subtitles/build_ass.py

          DUR=$(cat audio/voice_duration.txt)
          python3 subtitles/build_ass.py "$DUR"

      # ---------- Render final ----------
      - name: Render final video with subs + VO
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p final_video
          Vdur=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 selected_media/merged.mp4)
          Adur=$(cat audio/voice_duration.txt)
          need_pad=$(awk -v v="$Vdur" -v a="$Adur" 'BEGIN{print (v+0 < a+1.0)?1:0}')
          if [ "$need_pad" = "1" ]; then
            EXTRA=$(awk -v v="$Vdur" -v a="$Adur" 'BEGIN{d=a - v + 1.0; if (d<0) d=0; print d}')
            ffmpeg -nostdin -y -f lavfi -i "color=c=black:s=1080x1920:d=${EXTRA}" -r 30 -c:v libx264 -crf 18 -pix_fmt yuv420p -an selected_media/outro.mp4
            printf "file '%s'\n" "merged.mp4" > selected_media/full_list.txt
            printf "file '%s'\n" "outro.mp4" >> selected_media/full_list.txt
            ( cd selected_media && ffmpeg -nostdin -y -f concat -safe 0 -i full_list.txt -c copy merged.mp4 )
          fi

          ffmpeg -nostdin -y -i selected_media/merged.mp4 -i audio/voice.wav \
            -vf "subtitles=subtitles/captions.ass" \
            -map 0:v:0 -map 1:a:0 \
            -c:v libx264 -preset medium -crf 18 -pix_fmt yuv420p \
            -c:a aac -b:a 192k -shortest "final_video/${OUT_NAME}"

      - name: Upload artifact (final video)
        uses: actions/upload-artifact@v4
        with:
          name: final_video
          path: final_video/

      # ---------- Dropbox upload ----------
      - name: Upload to Dropbox (robuste)
        shell: bash
        run: |
          set -euo pipefail
          FILE="final_video/${OUT_NAME}"
          [ -s "$FILE" ] || { echo "Fichier absent: $FILE"; exit 1; }
          TOKEN="${DROPBOX_ACCESS_TOKEN}"
          REMOTE_DIR="/horror"
          TS=$(date +"%Y%m%d_%H%M%S")
          REMOTE_PATH="${REMOTE_DIR}/${TS}_${OUT_NAME}"
          SIZE=$(stat -c%s "$FILE")
          mkdir -p final_video

          if [ "$SIZE" -le $((150*1024*1024)) ]; then
            API_ARG=$(printf '{ "path": "%s", "mode": "add", "autorename": true, "mute": false }' "$REMOTE_PATH")
            RESP=$(curl -sS -X POST https://content.dropboxapi.com/2/files/upload \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Dropbox-API-Arg: ${API_ARG}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"${FILE}" ) || { echo "$RESP"; exit 1; }
          else
            CHUNK=$((15*1024*1024))
            SID=$(curl -sS -X POST https://content.dropboxapi.com/2/files/upload_session/start \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              -H 'Dropbox-API-Arg: {"close": false}' \
              --data-binary "" | python3 -c 'import sys,json;print(json.load(sys.stdin)["session_id"])')
            OFF=0
            I=0
            while [ "$OFF" -lt "$SIZE" ]; do
              dd if="$FILE" bs="$CHUNK" skip="$I" count=1 status=none | \
              curl -sS -X POST https://content.dropboxapi.com/2/files/upload_session/append_v2 \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Content-Type: application/octet-stream" \
                -H "Dropbox-API-Arg: {\"cursor\": {\"session_id\": \"${SID}\", \"offset\": ${OFF}}, \"close\": false}" \
                --data-binary @- >/dev/null
              OFF=$((OFF+CHUNK))
              I=$((I+1))
            done
            COMMIT=$(printf '{ "cursor": {"session_id": "%s", "offset": %s}, "commit": {"path": "%s", "mode": "add", "autorename": true, "mute": false} }' "$SID" "$SIZE" "$REMOTE_PATH")
            curl -sS -X POST https://content.dropboxapi.com/2/files/upload_session/finish \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              -H "Dropbox-API-Arg: ${COMMIT}" \
              --data-binary "" >/dev/null
          fi

          # Crée le lien (sans "requested_visibility") ; si déjà existant, on le récupère
          LINK=$(curl -sS -X POST https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            --data "{\"path\": \"${REMOTE_PATH}\"}" \
            | python3 -c 'import sys,json; print(json.load(sys.stdin).get("url",""))' || true)

          if [ -z "$LINK" ]; then
            LINK=$(curl -sS -X POST https://api.dropboxapi.com/2/sharing/list_shared_links \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"path\":\"${REMOTE_PATH}\",\"direct_only\":true}" \
              | python3 -c 'import sys,json; j=json.load(sys.stdin); print((j.get("links") or [{}])[0].get("url",""))' || true)
          fi

          if [ -z "$LINK" ]; then
            echo "Impossible d'obtenir un lien de partage Dropbox"
            exit 1
          fi

          LINK_DL="${LINK/\?dl=0/?dl=1}"
          printf '%s\n' "$LINK_DL" > final_video/dropbox_link.txt
          echo "Dropbox direct link: $LINK_DL"

      - name: Upload artifact (Dropbox link)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dropbox_link
          path: final_video/dropbox_link.txt