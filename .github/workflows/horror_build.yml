name: Build Horror Video (OpenAI + ElevenLabs + ASS + Dropbox)

on:
  workflow_dispatch: {}

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
      ELEVENLABS_VOICE_ID: ${{ secrets.ELEVENLABS_VOICE_ID }}
      MANIFEST_URL: ${{ secrets.MANIFEST_URL }}
      DROPBOX_ACCESS_TOKEN: ${{ secrets.DROPBOX_ACCESS_TOKEN }}
      CLIPS_COUNT: "13"
      OUT_NAME: "final_horror.mp4"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Installe d'abord les outils nécessaires
      - name: Install deps (ffmpeg, fonts, jq)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg jq fonts-dejavu-core

      # Ensuite seulement, vérifie les secrets et la présence des outils
      - name: Sanity checks (secrets + tools)
        run: |
          set -euo pipefail
          : "${OPENAI_API_KEY:?OPENAI_API_KEY manquant}"
          : "${ELEVENLABS_API_KEY:?ELEVENLABS_API_KEY manquant}"
          : "${ELEVENLABS_VOICE_ID:?ELEVENLABS_VOICE_ID manquant}"
          : "${MANIFEST_URL:?MANIFEST_URL manquant}"
          : "${DROPBOX_ACCESS_TOKEN:?DROPBOX_ACCESS_TOKEN manquant}"
          python3 --version
          ffmpeg -version >/dev/null
          jq --version >/dev/null


      - name: Install deps (ffmpeg, fonts, jq)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg jq fonts-dejavu-core

      # ===================== STORY (OpenAI) =====================
      - name: Generate story with OpenAI (FR)
        run: |
          set -euo pipefail
          mkdir -p story

          rm -f story/gen_openai.py
          printf "%s\n" "import json, pathlib" >> story/gen_openai.py
          printf "%s\n" "sys_txt = '''Tu écris un script court et ultra immersif d'horreur en français.'''" >> story/gen_openai.py
          printf "%s\n" "usr_txt = '''Écris un script TikTok ultra immerssif de 180 à 200 mots (65-75s). Structure : hook (10s), développement (45s), conclusion avec CTA (10s). Thème : horreur atmosphérique, manoir, pluie, bruits métalliques. Style concis, phrases courtes, sans grossièretés. NE METS AUCUNE DIDASCALIE DU TYPE Intro/Scène/Narrateur/CTA.''' " >> story/gen_openai.py
          printf "%s\n" "payload={'model':'gpt-4o-mini','temperature':1,'messages':[{'role':'system','content':sys_txt},{'role':'user','content':usr_txt}]}" >> story/gen_openai.py
          printf "%s\n" "pathlib.Path('story/payload.json').write_text(json.dumps(payload, ensure_ascii=False), encoding='utf-8')" >> story/gen_openai.py

          python3 story/gen_openai.py

          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @story/payload.json \
            -o story/openai.json

          # extraction sans heredoc
          rm -f story/extract_openai.py
          printf "%s\n" "import json, pathlib, re" >> story/extract_openai.py
          printf "%s\n" "j=json.load(open('story/openai.json','r',encoding='utf-8'))" >> story/extract_openai.py
          printf "%s\n" "txt=(j.get('choices') or [{}])[0].get('message',{}).get('content','')" >> story/extract_openai.py
          printf "%s\n" "txt=re.sub(r'\s+',' ',txt).strip()" >> story/extract_openai.py
          printf "%s\n" "pathlib.Path('story/story.txt').write_text(txt,encoding='utf-8')" >> story/extract_openai.py

          python3 story/extract_openai.py

      - name: Clean story (remove stage directions)
        run: |
          set -euo pipefail
          rm -f story/clean.py
          printf '%s\n' 'import re, pathlib' >> story/clean.py
          printf '%s\n' 'p=pathlib.Path("story/story.txt")' >> story/clean.py
          printf '%s\n' 's=p.read_text(encoding="utf-8") if p.exists() else ""' >> story/clean.py
          printf '%s\n' 's=re.sub(r"(?i)\b(intro|hook|scène|scene|narrateur|cta|conclusion|développement|developpement|seine)\b[:\-]?", "", s)' >> story/clean.py
          printf '%s\n' 's=re.sub(r"\[[^\]]*\]|\([^\)]*\)", "", s)' >> story/clean.py
          printf '%s\n' 's=s.replace("“","").replace("”","").replace("\"","")' >> story/clean.py
          printf '%s\n' 's=re.sub(r"\s+"," ",s).strip()' >> story/clean.py
          printf '%s\n' 'pathlib.Path("story/clean.txt").write_text(s,encoding="utf-8")' >> story/clean.py
          python3 story/clean.py
          [ -s story/clean.txt ] || { echo "Texte nettoyé vide"; exit 1; }

      # ===================== TTS (ElevenLabs) =====================
      - name: TTS with ElevenLabs + duration
        run: |
          set -euo pipefail
          mkdir -p audio

          rm -f audio/mk_payload.py
          printf '%s\n' 'import json, pathlib' >> audio/mk_payload.py
          printf '%s\n' 'txt=pathlib.Path("story/clean.txt").read_text(encoding="utf-8")' >> audio/mk_payload.py
          printf '%s\n' 'payload={"text":txt,"model_id":"eleven_multilingual_v2","voice_settings":{"stability":0.4,"similarity_boost":0.75}}' >> audio/mk_payload.py
          printf '%s\n' 'pathlib.Path("audio/tts_payload.json").write_text(json.dumps(payload,ensure_ascii=False),encoding="utf-8")' >> audio/mk_payload.py

          python3 audio/mk_payload.py

          curl -sS -X POST "https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}" \
            -H "xi-api-key: ${ELEVENLABS_API_KEY}" \
            -H "Content-Type: application/json" \
            --data-binary @audio/tts_payload.json \
            -o audio/voice.mp3

          ffmpeg -nostdin -y -i audio/voice.mp3 -ar 44100 -ac 2 audio/voice.wav
          ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 audio/voice.wav | tr -d '\r' > audio/voice_duration.txt
          [ -s audio/voice_duration.txt ] || { echo "Durée voix introuvable"; exit 1; }

      # ===================== MEDIA (manifest -> dl -> encode -> merge) =====================
      - name: Download manifest + clips, encode & merge (1080x1920/30)
        run: |
          set -euo pipefail
          mkdir -p selected_media
          curl -sS -fL "${MANIFEST_URL}" -o selected_media/manifest.txt
          [ -s selected_media/manifest.txt ] || { echo "Manifest vide"; exit 1; }

          # sélection sans heredoc
          rm -f selected_media/select_urls.py
          printf '%s\n' 'import random, pathlib, os, sys' >> selected_media/select_urls.py
          printf '%s\n' 'p=pathlib.Path("selected_media/manifest.txt")' >> selected_media/select_urls.py
          printf '%s\n' 'urls=[u.strip() for u in p.read_text(encoding="utf-8").splitlines() if u.strip() and not u.strip().startswith("#")]' >> selected_media/select_urls.py
          printf '%s\n' 'n=int(os.environ.get("CLIPS_COUNT","13"))' >> selected_media/select_urls.py
          printf '%s\n' 'random.shuffle(urls); sel=urls[:max(1,min(n,len(urls)))]' >> selected_media/select_urls.py
          printf '%s\n' 'pathlib.Path("selected_media/urls.txt").write_text("\n".join(sel),encoding="utf-8")' >> selected_media/select_urls.py
          python3 selected_media/select_urls.py

          cd selected_media
          rm -f list.txt
          i=0
          while IFS= read -r URL; do
            [ -n "$URL" ] || continue
            case "$URL" in \#*) continue;; esac
            i=$((i+1))
            SRC="src_${i}.mp4"
            OUT="seg_${i}.mp4"
            curl -sS -fL "$URL" -o "$SRC"
            ffmpeg -nostdin -y -i "$SRC" \
              -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1" \
              -r 30 -c:v libx264 -crf 18 -pix_fmt yuv420p -an "$OUT"
            printf "file '%s'\n" "$OUT" >> list.txt
          done < urls.txt

          [ -s list.txt ] || { echo "Aucun segment encodé"; exit 1; }
          ffmpeg -nostdin -y -f concat -safe 0 -i list.txt -c copy merged.mp4

          Vdur="$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 merged.mp4 | tr -d '\r')"
          Adur="$(cat ../audio/voice_duration.txt | tr -d '\r')"
          EXTRA="$(python3 -c 'import sys; v=float(sys.argv[1]); a=float(sys.argv[2]); print(max(0.0, a - v + 0.6))' "$Vdur" "$Adur")"
          PAD_NEED="$(python3 -c 'import sys; x=float(sys.argv[1]); print(1 if x>0.05 else 0)' "$EXTRA")"
          if [ "$PAD_NEED" = "1" ]; then
            ffmpeg -nostdin -y -f lavfi -i "color=c=black:s=1080x1920:d=${EXTRA}" -r 30 -c:v libx264 -crf 18 -pix_fmt yuv420p -an outro.mp4
            rm -f full_list.txt
            printf "file '%s'\n" "merged.mp4" > full_list.txt
            printf "file '%s'\n" "outro.mp4" >> full_list.txt
            ffmpeg -nostdin -y -f concat -safe 0 -i full_list.txt -c copy merged.mp4
          fi
          cd ..

      # ===================== SUBTITLES (karaoke .ass) =====================
      - name: Build captions.ass (karaoke)
        run: |
          set -euo pipefail
          mkdir -p subtitles
          rm -f subtitles/build_ass.py

          printf '%s\n' 'import re, math' >> subtitles/build_ass.py
          printf '%s\n' 'from pathlib import Path' >> subtitles/build_ass.py
          printf '%s\n' 'dur=float(Path("audio/voice_duration.txt").read_text().strip())' >> subtitles/build_ass.py
          printf '%s\n' 'p_clean=Path("story/clean.txt")' >> subtitles/build_ass.py
          printf '%s\n' 'txt=(p_clean.read_text(encoding="utf-8") if p_clean.exists() else Path("story/story.txt").read_text(encoding="utf-8"))' >> subtitles/build_ass.py
          printf '%s\n' 'txt=re.sub(r"(?i)\b(intro|hook|scène|scene|narrateur|cta|conclusion|développement)\b[:\-]?", "", txt)' >> subtitles/build_ass.py
          printf '%s\n' 'txt=re.sub(r"\s+"," ",txt).strip()' >> subtitles/build_ass.py
          printf '%s\n' 'words=re.findall(r"\S+", txt); n=len(words)' >> subtitles/build_ass.py
          printf '%s\n' 'if n==0: Path("subtitles/captions.ass").write_text("",encoding="utf-8"); raise SystemExit(0)' >> subtitles/build_ass.py
          printf '%s\n' 'per=max(dur/max(n/6,1), 0.35); MINL,MAXL=2.0,4.0' >> subtitles/build_ass.py

          printf '%s\n' 'def ts(x):' >> subtitles/build_ass.py
          printf '%s\n' '  total=max(0.0,float(x))' >> subtitles/build_ass.py
          printf '%s\n' '  h=int(total//3600); m=int((total%3600)//60); s=int(total%60)' >> subtitles/build_ass.py
          printf '%s\n' '  cs=int(round((total-int(total))*100))' >> subtitles/build_ass.py
          printf '%s\n' '  if cs==100: cs=0; s+=1' >> subtitles/build_ass.py
          printf '%s\n' '  if s==60: s=0; m+=1' >> subtitles/build_ass.py
          printf '%s\n' '  if m==60: m=0; h+=1' >> subtitles/build_ass.py
          printf '%s\n' '  return f"{h:d}:{m:02d}:{s:02d}.{cs:02d}"' >> subtitles/build_ass.py

          printf '%s\n' 'hdr=["[Script Info]","ScriptType: v4.00+","PlayResX: 1080","PlayResY: 1920","ScaledBorderAndShadow: yes","",' >> subtitles/build_ass.py
          printf '%s\n' '"[V4+ Styles]","Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding",' >> subtitles/build_ass.py
          printf '%s\n' '"Style: TikTok,DejaVu Sans,62,&H00FFFFFF,&H00404040,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2.8,0.6,2,30,30,54,0","","[Events]","Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"]' >> subtitles/build_ass.py
          printf '%s\n' 'Path("subtitles/captions.ass").write_text("\n".join(hdr)+"\n", encoding="utf-8")' >> subtitles/build_ass.py

          printf '%s\n' 't=0.0; acc=0.0; buf=[]; lines=[]' >> subtitles/build_ass.py
          printf '%s\n' 'for w in words:' >> subtitles/build_ass.py
          printf '%s\n' '  buf.append(w); acc+=per' >> subtitles/build_ass.py
          printf '%s\n' '  if (acc>=MINL and (acc>=MAXL or len(buf)>=8)):' >> subtitles/build_ass.py
          printf '%s\n' '    s=t; e=min(t+acc, dur); lines.append((s,e,buf[:])); t=e; buf=[]; acc=0.0' >> subtitles/build_ass.py
          printf '%s\n' 'if buf: s=t; e=min(t+max(acc,1.4), dur); lines.append((s,e,buf[:]))' >> subtitles/build_ass.py

          printf '%s\n' 'with open("subtitles/captions.ass","a",encoding="utf-8") as f:' >> subtitles/build_ass.py
          printf '%s\n' '  for s,e,ws in lines:' >> subtitles/build_ass.py
          printf '%s\n' '    total=max(0.8, e-s); lens=[max(1,len(x)) for x in ws]; L=sum(lens)' >> subtitles/build_ass.py
          printf '%s\n' '    cs=[max(1,int(round(total*100*l/L))) for l in lens]; diff=int(round(total*100))-sum(cs)' >> subtitles/build_ass.py
          printf '%s\n' '    if diff!=0: cs[-1]+=diff' >> subtitles/build_ass.py
          printf '%s\n' '    kara="".join([f"{\\k%s}"%k + w + " " for w,k in zip(ws,cs)]).rstrip()' >> subtitles/build_ass.py
          printf '%s\n' '    f.write(f"Dialogue: 0,{ts(s)},{ts(e)},TikTok,,0,0,0,,{kara}\n")' >> subtitles/build_ass.py

          python3 subtitles/build_ass.py
          [ -s subtitles/captions.ass ] || { echo "ASS vide"; exit 1; }

      # ===================== RENDER =====================
      - name: Render final (burn ASS + audio)
        run: |
          set -euo pipefail
          mkdir -p final_video
          ffmpeg -nostdin -y \
            -i selected_media/merged.mp4 \
            -i audio/voice.wav \
            -vf "subtitles=subtitles/captions.ass" \
            -map 0:v:0 -map 1:a:0 \
            -c:v libx264 -preset medium -crf 18 -pix_fmt yuv420p \
            -c:a aac -b:a 192k -shortest "final_video/${OUT_NAME}"
          [ -s "final_video/${OUT_NAME}" ] || { echo "Rendu final absent"; exit 1; }

      - name: Upload artifacts (media, audio, subs, final)
        uses: actions/upload-artifact@v4
        with:
          name: build_outputs
          path: |
            selected_media/
            audio/
            subtitles/
            final_video/

      # ===================== DROPBOX =====================
      - name: Upload to Dropbox + link
        run: |
          set -euo pipefail
          : "${DROPBOX_ACCESS_TOKEN:?DROPBOX_ACCESS_TOKEN manquant}"
          : "${OUT_NAME:?OUT_NAME manquant}"
          FILE="final_video/${OUT_NAME}"
          [ -s "$FILE" ] || { echo "Fichier absent: $FILE"; exit 1; }

          TOKEN="${DROPBOX_ACCESS_TOKEN}"
          REMOTE_DIR="/horror"
          TS="$(date +'%Y%m%d_%H%M%S')"
          REMOTE_PATH="${REMOTE_DIR}/${TS}_${OUT_NAME}"
          SIZE="$(stat -c%s "$FILE")"
          mkdir -p final_video

          if [ "$SIZE" -le $((150*1024*1024)) ]; then
            API_ARG=$(printf '{ "path": "%s", "mode": "add", "autorename": true, "mute": false }' "$REMOTE_PATH")
            CODE=$(curl -sS -X POST "https://content.dropboxapi.com/2/files/upload" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Dropbox-API-Arg: ${API_ARG}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"${FILE}" \
              -o /tmp/dbx_upload.json -w '%{http_code}')
            [ "$CODE" -ge 200 ] && [ "$CODE" -lt 300 ] || { echo "Upload Dropbox échec http=$CODE"; cat /tmp/dbx_upload.json || true; exit 1; }
          else
            CHUNK=$((15*1024*1024))
            SID=$(curl -sS -X POST "https://content.dropboxapi.com/2/files/upload_session/start" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              -H 'Dropbox-API-Arg: {"close": false}' \
              --data-binary "" | python3 -c 'import sys,json; s=sys.stdin.read().strip(); print(json.loads(s)["session_id"] if s else "", end="")' 2>/dev/null || true)
            [ -n "${SID:-}" ] || { echo "Session upload Dropbox KO"; exit 1; }

            OFF=0; I=0
            while [ "$OFF" -lt "$SIZE" ]; do
              dd if="$FILE" bs="$CHUNK" skip="$I" count=1 status=none | \
              curl -sS -X POST "https://content.dropboxapi.com/2/files/upload_session/append_v2" \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Content-Type: application/octet-stream" \
                -H "Dropbox-API-Arg: {\"cursor\": {\"session_id\": \"${SID}\", \"offset\": ${OFF}}, \"close\": false}" \
                --data-binary @- >/dev/null
              OFF=$((OFF+CHUNK)); I=$((I+1))
            done

            COMMIT=$(printf '{ "cursor": {"session_id": "%s", "offset": %s}, "commit": {"path": "%s", "mode": "add", "autorename": true, "mute": false} }' "$SID" "$SIZE" "$REMOTE_PATH")
            CODE=$(curl -sS -X POST "https://content.dropboxapi.com/2/files/upload_session/finish" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              -H "Dropbox-API-Arg: ${COMMIT}" \
              --data-binary "" -o /tmp/dbx_finish.json -w '%{http_code}')
            [ "$CODE" -ge 200 ] && [ "$CODE" -lt 300 ] || { echo "Finalisation upload Dropbox KO http=$CODE"; cat /tmp/dbx_finish.json || true; exit 1; }
          fi

          PAYLOAD=$(printf '{"path":"%s"}' "$REMOTE_PATH")
          CODE=$(curl -sS -X POST "https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$PAYLOAD" -o /tmp/dbx_link.json -w '%{http_code}')
          URL=""
          if [ -s /tmp/dbx_link.json ]; then
            URL=$(python3 -c 'import sys,json; s=open("/tmp/dbx_link.json","r",encoding="utf-8").read().strip(); print(json.loads(s).get("url","") if s else "", end="")' 2>/dev/null || true)
          fi
          if [ -z "$URL" ]; then
            CODE=$(curl -sS -X POST "https://api.dropboxapi.com/2/sharing/list_shared_links" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"path\":\"${REMOTE_PATH}\",\"direct_only\":true}" -o /tmp/dbx_list.json -w '%{http_code}')
            if [ -s /tmp/dbx_list.json ]; then
              URL=$(python3 -c 'import sys,json; s=open("/tmp/dbx_list.json","r",encoding="utf-8").read().strip(); j=json.loads(s) if s else {}; print(((j.get("links") or [{}])[0].get("url","")), end="")' 2>/dev/null || true)
            fi
          fi
          [ -n "$URL" ] || { echo "Lien Dropbox indisponible"; exit 1; }

          LINK_DL="${URL/\?dl=0/?dl=1}"
          printf '%s\n' "$LINK_DL" > final_video/dropbox_link.txt
          echo "Dropbox direct link: $LINK_DL"

      - name: Upload artifact (Dropbox link)
        uses: actions/upload-artifact@v4
        with:
          name: dropbox_link
          path: final_video/dropbox_link.txt