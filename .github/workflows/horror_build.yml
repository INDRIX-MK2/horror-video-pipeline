name: Horror Build

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      CLIPS_COUNT: "13"
      OUT_NAME: "final_horror.mp4"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps (ffmpeg, jq, coreutils)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg jq

      - name: Fetch bank videos from MANIFEST_URL (optional)
        shell: bash
        env:
          MANIFEST_URL: ${{ secrets.MANIFEST_URL }}
        run: |
          set -euo pipefail
          mkdir -p bank_video/Horreur
          if [ -n "${MANIFEST_URL:-}" ]; then
            TMP="$(mktemp)"
            # Si MANIFEST_URL pointe vers un fichier texte en ligne (1 URL par ligne)
            if curl -fsSL "$MANIFEST_URL" -o "$TMP"; then
              awk 'NF{print $0}' "$TMP" > manifest_urls.txt
            else
              # Sinon, traite MANIFEST_URL comme une liste d’URLs séparées par espaces/nouvelles lignes
              printf '%s\n' $MANIFEST_URL > manifest_urls.txt
            fi
            # Téléchargements
            i=0
            while IFS= read -r u; do
              [ -n "$u" ] || continue
              i=$((i+1))
              base="$(basename "${u%%\?*}")"
              case "$base" in
                *.mp4) fn="$base" ;;
                *) fn="clip_${i}.mp4" ;;
              esac
              curl -fsSL "$u" -o "bank_video/Horreur/$fn"
            done < manifest_urls.txt
          fi
          # Vérification d’au moins 2 sources
          CNT=$(find bank_video/Horreur -maxdepth 1 -type f -name '*.mp4' | wc -l | tr -d ' ')
          if [ "$CNT" -lt 2 ]; then
            echo "Il faut au moins 2 vidéos MP4 dans bank_video/Horreur (actuellement: $CNT)."
            exit 1
          fi

      - name: Generate story (OpenAI)
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          : "${OPENAI_API_KEY:?OPENAI_API_KEY manquant}"
          mkdir -p story
          SYS="Tu écris un script court et immersif d'horreur en français. Aucune didascalie. N'utilise jamais des mots comme Scène, Narrateur, Hook, Intro, CTA, Caméra. Uniquement la narration immersive à la première personne."
          USER="Écris un script Tiktok immersif de 180 à 200 mots (65-75s). Thème : horreur atmosphérique. Style concis, phrases courtes, sans grossièretés. Pas de didascalies, uniquement la narration."
          jq -n --arg sys "$SYS" --arg user "$USER" \
            '{model:"gpt-4o",temperature:1,messages:[{role:"system",content:$sys},{role:"user",content:$user}]}' \
            > story/payload.json
          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @story/payload.json \
            | jq -r '.choices[0].message.content' \
            | sed 's/\r//g' > story/story.txt
          [ -s story/story.txt ] || { echo "Texte OpenAI vide"; exit 1; }

      - name: Sanitize narration (supprimer Scène/Narrateur/CTA/etc.)
        shell: bash
        run: |
          set -euo pipefail
          [ -s story/story.txt ] || { echo "story/story.txt manquant"; exit 1; }
          tr -d '\r' < story/story.txt \
          | sed -E '
            s/[“”"]//g;
            s/\b(Intro|Hook|Accroche|Développement|Conclusion|CTA|Scène|Scene|Narrateur|Narratrice|VOIX[[:space:]]*OFF|Cam(é|e)ra|Gros[[:space:]]*plan|Plan[[:space:]]*serré)\b:?[[:space:]]*//gi;
            s/\[[^]]*\]//g;
            s/\([^)]*\)//g;
            s/[[:space:]]+/ /g;
            s/^[[:space:]]+//; s/[[:space:]]+$//;
          ' > story/clean.txt
          [ -s story/clean.txt ] || { echo "Texte nettoyé vide (vérifie le prompt)"; exit 1; }

      - name: TTS ElevenLabs (depuis clean.txt)
        shell: bash
        env:
          ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
          ELEVENLABS_VOICE_ID: ${{ secrets.ELEVENLABS_VOICE_ID }}
        run: |
          set -euo pipefail
          : "${ELEVENLABS_API_KEY:?ELEVENLABS_API_KEY manquant}"
          : "${ELEVENLABS_VOICE_ID:?ELEVENLABS_VOICE_ID manquant}"
          mkdir -p audio
          TEXT="$(cat story/clean.txt)"
          PAYLOAD="$(jq -n --arg t "$TEXT" \
            '{text:$t,voice_settings:{stability:0.5,similarity_boost:0.75}}')"
          curl -sS -X POST "https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}" \
            -H "xi-api-key: ${ELEVENLABS_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" --output audio/voice.mp3
          [ -s audio/voice.mp3 ] || { echo "TTS vide"; exit 1; }
          ffmpeg -nostdin -y -i audio/voice.mp3 -ar 48000 -ac 2 -c:a pcm_s16le audio/voice.wav
          [ -s audio/voice.wav ] || { echo "Conversion WAV échouée"; exit 1; }

      - name: Build subtitles (.ass, style TikTok + karaoké simple)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p subtitles
          # Header ASS
          {
            printf '%s\n' '[Script Info]'
            printf '%s\n' 'ScriptType: v4.00+'
            printf '%s\n' 'PlayResX: 1080'
            printf '%s\n' 'PlayResY: 1920'
            printf '%s\n' ''
            printf '%s\n' '[V4+ Styles]'
            printf '%s\n' 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding'
            printf '%s\n' 'Style: TikTok,Montserrat SemiBold,64,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,4,1,2,60,60,120,1'
            printf '%s\n' ''
            printf '%s\n' '[Events]'
            printf '%s\n' 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text'
          } > subtitles/captions.ass

          # Durée audio
          D=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 audio/voice.wav || echo "")
          [ -n "$D" ] || D=60

          # Segmentation ~5 mots/ligne, calée sur la durée
          awk -v dur="$D" '
            function ts(x,  h,m,s,cs){h=int(x/3600);m=int((x%3600)/60);s=int(x%60);cs=int((x-int(x))*100);return sprintf("%01d:%02d:%02d.%02d",h,m,s,cs)}
            BEGIN{FS="[ \t]+"}
            { for(i=1;i<=NF;i++){ if($i!=""){ w[++n]=$i } } }
            END{
              if(n<1) exit 0;
              per=dur/(n>0?n:1);
              t=0; i=1; maxw=5;
              while(i<=n){
                txt=w[i]; c=1; i++;
                while(c<maxw && i<=n){ txt=txt" "w[i]; i++; c++ }
                s=t; e=t+per*c;
                gsub(/\{/,"(",txt); gsub(/\}/,")",txt);
                printf("Dialogue: 0,%s,%s,TikTok,,0,0,0,,%s\n", ts(s), ts(e), txt);
                t=e;
              }
            }
          ' story/clean.txt >> subtitles/captions.ass

          [ -s subtitles/captions.ass ] || { echo "ASS vide"; exit 1; }

      - name: Select clips and merge (vertical 1080x1920/30fps)
        shell: bash
        env:
          CLIPS_COUNT: ${{ env.CLIPS_COUNT }}
        run: |
          set -euo pipefail
          mkdir -p selected_media
          : "${CLIPS_COUNT:=13}"

          mapfile -t ALL < <(find bank_video/Horreur -maxdepth 1 -type f -name '*.mp4' | sort)
          [ "${#ALL[@]}" -gt 0 ] || { echo "Aucun .mp4 dans bank_video/Horreur"; exit 1; }

          mapfile -t SEL < <(printf '%s\n' "${ALL[@]}" | shuf | head -n "$CLIPS_COUNT")
          [ "${#SEL[@]}" -ge 2 ] || { echo "Moins de 2 vidéos sélectionnées → montage pauvre"; exit 1; }

          rm -f selected_media/list.txt
          i=0
          for SRC in "${SEL[@]}"; do
            i=$((i+1))
            OUT="selected_media/seg_${i}.mp4"
            ffmpeg -nostdin -y -i "$SRC" \
              -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1" \
              -r 30 -c:v libx264 -preset medium -crf 18 -pix_fmt yuv420p -an "$OUT"
            printf "file '%s'\n" "$OUT" >> selected_media/list.txt
          done

          ffmpeg -nostdin -y -f concat -safe 0 -i selected_media/list.txt -c copy selected_media/merged.mp4
          [ -s selected_media/merged.mp4 ] || { echo "concat échouée"; exit 1; }

      - name: Render final with subtitles
        shell: bash
        env:
          OUT_NAME: ${{ env.OUT_NAME }}
        run: |
          set -euo pipefail
          mkdir -p final_video
          ffmpeg -nostdin -y \
            -i selected_media/merged.mp4 -i audio/voice.wav \
            -vf "subtitles=subtitles/captions.ass" \
            -map 0:v:0 -map 1:a:0 \
            -c:v libx264 -preset medium -crf 18 -pix_fmt yuv420p \
            -c:a aac -b:a 192k -shortest "final_video/${OUT_NAME}"
          [ -s "final_video/${OUT_NAME}" ] || { echo "Export final manqué"; exit 1; }

      - name: Upload artifact (final video)
        uses: actions/upload-artifact@v4
        with:
          name: final_video
          path: final_video/

      - name: Upload to Dropbox (file + shared link)
        shell: bash
        env:
          DROPBOX_ACCESS_TOKEN: ${{ secrets.DROPBOX_ACCESS_TOKEN }}
          OUT_NAME: ${{ env.OUT_NAME }}
        run: |
          set -euo pipefail
          : "${DROPBOX_ACCESS_TOKEN:?DROPBOX_ACCESS_TOKEN manquant}"
          : "${OUT_NAME:?OUT_NAME manquant}"

          FILE="final_video/${OUT_NAME}"
          [ -s "$FILE" ] || { echo "Fichier absent ou vide: $FILE"; exit 1; }

          TOKEN="$DROPBOX_ACCESS_TOKEN"
          REMOTE_DIR="/horror"
          TS="$(date +"%Y%m%d_%H%M%S")"
          REMOTE_PATH="${REMOTE_DIR}/${TS}_${OUT_NAME}"
          SIZE="$(stat -c%s "$FILE")"
          mkdir -p final_video

          if [ "$SIZE" -le $((150*1024*1024)) ]; then
            API_ARG=$(printf '{ "path": "%s", "mode": "add", "autorename": true, "mute": false }' "$REMOTE_PATH")
            CODE=$(curl -sS -X POST "https://content.dropboxapi.com/2/files/upload" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Dropbox-API-Arg: ${API_ARG}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"${FILE}" \
              -o /tmp/dbx_upload.json -w '%{http_code}')
            echo "UPLOAD http=$CODE"
            [ -s /tmp/dbx_upload.json ] && echo "UPLOAD body: $(head -c 400 /tmp/dbx_upload.json)"
            if [ "$CODE" -lt 200 ] || [ "$CODE" -ge 300 ]; then
              echo "Échec upload Dropbox"
              exit 1
            fi
          else
            CHUNK=$((15*1024*1024))
            SID=$(curl -sS -X POST "https://content.dropboxapi.com/2/files/upload_session/start" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              -H 'Dropbox-API-Arg: {"close": false}' \
              --data-binary "" | jq -r '.session_id // empty')
            [ -n "$SID" ] || { echo "Impossible d'ouvrir une session d'upload"; exit 1; }
            OFF=0
            I=0
            while [ "$OFF" -lt "$SIZE" ]; do
              dd if="$FILE" bs="$CHUNK" skip="$I" count=1 status=none | \
              curl -sS -X POST "https://content.dropboxapi.com/2/files/upload_session/append_v2" \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Content-Type: application/octet-stream" \
                -H "Dropbox-API-Arg: {\"cursor\": {\"session_id\": \"${SID}\", \"offset\": ${OFF}}, \"close\": false}" \
                --data-binary @- >/dev/null
              OFF=$((OFF+CHUNK))
              I=$((I+1))
            done
            COMMIT=$(printf '{ "cursor": {"session_id": "%s", "offset": %s}, "commit": {"path": "%s", "mode": "add", "autorename": true, "mute": false} }' "$SID" "$SIZE" "$REMOTE_PATH")
            CODE=$(curl -sS -X POST "https://content.dropboxapi.com/2/files/upload_session/finish" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              -H "Dropbox-API-Arg: ${COMMIT}" \
              --data-binary "" -o /tmp/dbx_finish.json -w '%{http_code}')
            echo "FINISH http=$CODE"
            [ -s /tmp/dbx_finish.json ] && echo "FINISH body: $(head -c 400 /tmp/dbx_finish.json)"
            if [ "$CODE" -lt 200 ] || [ "$CODE" -ge 300 ]; then
              echo "Échec finalisation upload Dropbox"
              exit 1
            fi
          fi

          # Lien partageable
          PAYLOAD=$(printf '{"path":"%s"}' "$REMOTE_PATH")
          CODE=$(curl -sS -X POST "https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$PAYLOAD" \
            -o /tmp/dbx_link.json -w '%{http_code}')
          echo "LINK http=$CODE"
          [ -s /tmp/dbx_link.json ] && echo "LINK body: $(head -c 400 /tmp/dbx_link.json)"

          URL=$(jq -r '.url // empty' /tmp/dbx_link.json 2>/dev/null || true)
          if [ -z "$URL" ]; then
            CODE=$(curl -sS -X POST "https://api.dropboxapi.com/2/sharing/list_shared_links" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"path\":\"${REMOTE_PATH}\",\"direct_only\":true}" \
              -o /tmp/dbx_list.json -w '%{http_code}')
            echo "LIST http=$CODE"
            [ -s /tmp/dbx_list.json ] && echo "LIST body: $(head -c 400 /tmp/dbx_list.json)"
            URL=$(jq -r '.links[0].url // empty' /tmp/dbx_list.json 2>/dev/null || true)
          fi

          if [ -z "$URL" ]; then
            echo "Impossible d'obtenir un lien de partage Dropbox."
            exit 1
          fi

          LINK_DL="${URL/\?dl=0/?dl=1}"
          printf '%s\n' "$LINK_DL" > final_video/dropbox_link.txt
          echo "Dropbox direct link: $LINK_DL"

      - name: Upload artifact (Dropbox link)
        uses: actions/upload-artifact@v4
        with:
          name: dropbox_link
          path: final_video/dropbox_link.txt