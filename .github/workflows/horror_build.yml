name: Horror Video Pipeline (Dropbox, no-jq, no-heredoc)

on:
  workflow_dispatch:
    inputs:
      clips_count:
        description: "Nombre de clips à assembler"
        required: false
        default: "13"
      out_name:
        description: "Nom du fichier de sortie"
        required: false
        default: "final_horror.mp4"

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
      ELEVENLABS_VOICE_ID: ${{ secrets.ELEVENLABS_VOICE_ID }}
      MANIFEST_URL: ${{ secrets.MANIFEST_URL }}
      DROPBOX_ACCESS_TOKEN: ${{ secrets.DROPBOX_ACCESS_TOKEN }}
      CLIPS_COUNT: ${{ github.event.inputs.clips_count || '13' }}
      OUT_NAME: ${{ github.event.inputs.out_name || 'final_horror.mp4' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required secrets
        shell: bash
        run: |
          set -euo pipefail
          miss=()
          for v in OPENAI_API_KEY ELEVENLABS_API_KEY ELEVENLABS_VOICE_ID MANIFEST_URL DROPBOX_ACCESS_TOKEN; do
            if [ -z "${!v:-}" ]; then miss+=("$v"); fi
          done
          if [ "${#miss[@]}" -gt 0 ]; then
            echo "Secrets manquants: ${miss[*]}"
            exit 1
          fi

      - name: Install tools
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg python3

      # ---------- Story (OpenAI) ----------
      - name: Generate story (OpenAI) - build payload script
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p story scripts
          printf '%s\n' "import json, os, sys" > scripts/mk_openai_payload.py
          printf '%s\n' "sys_text = os.environ.get('SYS','')" >> scripts/mk_openai_payload.py
          printf '%s\n' "user_text = os.environ.get('USER_PROMPT','')" >> scripts/mk_openai_payload.py
          printf '%s\n' "payload={" >> scripts/mk_openai_payload.py
          printf '%s\n' "  \"model\":\"gpt-4o-mini\"," >> scripts/mk_openai_payload.py
          printf '%s\n' "  \"temperature\":1," >> scripts/mk_openai_payload.py
          printf '%s\n' "  \"messages\":[{\"role\":\"system\",\"content\":sys_text},{\"role\":\"user\",\"content\":user_text}]" >> scripts/mk_openai_payload.py
          printf '%s\n' "}" >> scripts/mk_openai_payload.py
          printf '%s\n' "json.dump(payload, sys.stdout, ensure_ascii=False)" >> scripts/mk_openai_payload.py

          printf '%s\n' "import json, sys" > scripts/extract_openai_text.py
          printf '%s\n' "data=json.load(open(sys.argv[1],'r',encoding='utf-8'))" >> scripts/extract_openai_text.py
          printf '%s\n' "print(data['choices'][0]['message']['content'])" >> scripts/extract_openai_text.py

      - name: Generate story (OpenAI) - call API
        shell: bash
        run: |
          set -euo pipefail
          # On place les textes ici (plus d'env YAML piégeux)
          SYS="Tu écris un script court et immersif d'horreur en français."
          USER_PROMPT="Écris un script TikTok de 180 à 200 mots (65-75s). Structure : hook (10s), développement (45s), conclusion avec CTA (10s). Thème : horreur atmosphérique, manoir, pluie, bruits métalliques. Style concis, phrases courtes, sans grossièretés."

          mkdir -p story
          SYS="$SYS" USER_PROMPT="$USER_PROMPT" python3 scripts/mk_openai_payload.py > story/payload.json

          HTTP_CODE=$(curl -sS -o story/resp.json -w "%{http_code}" \
            https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            --data-binary @story/payload.json)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "OpenAI HTTP $HTTP_CODE"
            head -c 500 story/resp.json || true
            exit 1
          fi

          python3 scripts/extract_openai_text.py story/resp.json > story/story.txt
          if [ ! -s story/story.txt ]; then echo "Story vide"; exit 1; fi

      # ---------- Ingest clips ----------
      - name: Download manifest & clips
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p bank_video/Horreur selected_media
          curl -sSL "$MANIFEST_URL" -o selected_media/manifest_urls.txt
          awk 'NF' selected_media/manifest_urls.txt > selected_media/urls.txt

          mapfile -t URLS < selected_media/urls.txt
          if [ "${#URLS[@]}" -eq 0 ]; then echo "Aucune URL dans le manifest"; exit 1; fi

          printf '%s\n' "${URLS[@]}" | shuf > selected_media/urls_shuf.txt
          mapfile -t SEL < <(head -n "$CLIPS_COUNT" selected_media/urls_shuf.txt)

          : > selected_media/manifest.txt
          idx=0
          for u in "${SEL[@]}"; do
            idx=$((idx+1))
            nm=$(printf 'clip_%02d.mp4' "$idx")
            dest="bank_video/Horreur/$nm"
            curl -L --fail --retry 3 --retry-all-errors -o "$dest" "$u"
            printf '%s\n' "$dest" >> selected_media/manifest.txt
          done

      # ---------- Normalize + concat ----------
      - name: Normalize clips and concat (1080x1920/30fps + effets)
        shell: bash
        run: |
          set -euo pipefail
          rm -f selected_media/list.txt
          i=0
          while IFS= read -r SRC; do
            [ -n "$SRC" ] || continue
            i=$((i+1))
            OUT="selected_media/seg_${i}.mp4"
            ffmpeg -nostdin -y -i "$SRC" \
              -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,eq=contrast=1.08:brightness=0.02:saturation=1.05,vignette,noise=alls=10:allf=t+u" \
              -r 30 -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -an "$OUT"
            printf "file '%s'\n" "seg_${i}.mp4" >> selected_media/list.txt
          done < selected_media/manifest.txt

          ( cd selected_media && ffmpeg -nostdin -y -f concat -safe 0 -i list.txt -c copy merged.mp4 )

      # ---------- TTS (ElevenLabs) ----------
      - name: Generate voiceover (ElevenLabs)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p audio scripts
          TEXT=$(tr '\n' ' ' < story/story.txt | sed 's/  */ /g' | sed 's/"/\\"/g')

          printf '%s\n' "import json, os, sys" > scripts/mk_eleven_payload.py
          printf '%s\n' "text=os.environ.get('TTS_TEXT','')" >> scripts/mk_eleven_payload.py
          printf '%s\n' "payload={\"text\":text,\"model_id\":\"eleven_multilingual_v2\",\"voice_settings\":{\"stability\":0.4,\"similarity_boost\":0.8}}" >> scripts/mk_eleven_payload.py
          printf '%s\n' "json.dump(payload, sys.stdout, ensure_ascii=False)" >> scripts/mk_eleven_payload.py

          TTS_TEXT="$TEXT" python3 scripts/mk_eleven_payload.py > audio/tts_payload.json

          curl -sS -X POST "https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}" \
            -H "xi-api-key: ${ELEVENLABS_API_KEY}" \
            -H "Content-Type: application/json" \
            --data-binary @audio/tts_payload.json \
            --output audio/voice.mp3

          ffmpeg -nostdin -y -i audio/voice.mp3 -ar 44100 -ac 2 audio/voice.wav
          ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 audio/voice.wav > audio/voice_duration.txt

      # ---------- Subtitles (.ass) ----------
      - name: Build subtitles (.ass)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p subtitles

          printf '%s\n' "[Script Info]" > subtitles/captions.ass
          printf '%s\n' "ScriptType: v4.00+" >> subtitles/captions.ass
          printf '%s\n' "PlayResX: 1080" >> subtitles/captions.ass
          printf '%s\n' "PlayResY: 1920" >> subtitles/captions.ass
          printf '%s\n' "Timer: 100.0000" >> subtitles/captions.ass
          printf '\n' >> subtitles/captions.ass
          printf '%s\n' "[V4+ Styles]" >> subtitles/captions.ass
          printf '%s\n' "Format: Name,Fontname,Fontsize,PrimaryColour,SecondaryColour,OutlineColour,BackColour,Bold,Italic,Underline,StrikeOut,ScaleX,ScaleY,Spacing,Angle,BorderStyle,Outline,Shadow,Alignment,MarginL,MarginR,MarginV,Encoding" >> subtitles/captions.ass
          printf '%s\n' "Style: TikTok,Montserrat SemiBold,56,&H00FFFFFF,&H00FFFFFF,&H00222222,&H66000000,-1,0,0,0,100,100,0,0,1,3,0,2,50,50,60,1" >> subtitles/captions.ass
          printf '\n' >> subtitles/captions.ass
          printf '%s\n' "[Events]" >> subtitles/captions.ass
          printf '%s\n' "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text" >> subtitles/captions.ass

          printf '%s\n' "import sys" > subtitles/build_ass.py
          printf '%s\n' "dur=float(sys.argv[1])" >> subtitles/build_ass.py
          printf '%s\n' "txt=open('story/story.txt','r',encoding='utf-8').read().strip().replace('\n',' ')" >> subtitles/build_ass.py
          printf '%s\n' "words=txt.split()" >> subtitles/build_ass.py
          printf '%s\n' "n=len(words)" >> subtitles/build_ass.py
          printf '%s\n' "per=max(dur/max(n/5,1), 2.0)" >> subtitles/build_ass.py
          printf '%s\n' "t=0.0; acc=0.0; buf=[]; lines=[]" >> subtitles/build_ass.py
          printf '%s\n' "def ts(x):" >> subtitles/build_ass.py
          printf '%s\n' "    m=int(x//60); s=int(x%60); cs=int(round((x-m*60-s)*100))" >> subtitles/build_ass.py
          printf '%s\n' "    return f'{m:d}:{s:02d}:{cs:02d}.00'" >> subtitles/build_ass.py
          printf '%s\n' "for w in words:" >> subtitles/build_ass.py
          printf '%s\n' "    buf.append(w); acc+=per" >> subtitles/build_ass.py
          printf '%s\n' "    if acc>=2.8:" >> subtitles/build_ass.py
          printf '%s\n' "        start=t; end=min(t+acc, dur)" >> subtitles/build_ass.py
          printf '%s\n' "        lines.append((start,end,' '.join(buf))); t=end; buf=[]; acc=0.0" >> subtitles/build_ass.py
          printf '%s\n' "if buf:" >> subtitles/build_ass.py
          printf '%s\n' "    start=t; end=min(t+(acc if acc>0 else 2.0), dur)" >> subtitles/build_ass.py
          printf '%s\n' "    lines.append((start,end,' '.join(buf)))" >> subtitles/build_ass.py
          printf '%s\n' "with open('subtitles/captions.ass','a',encoding='utf-8') as f:" >> subtitles/build_ass.py
          printf '%s\n' "    for s,e,text in lines:" >> subtitles/build_ass.py
          printf '%s\n' "        print(f'Dialogue: 0,{ts(s)},{ts(e)},TikTok,,0,0,0,,{text}', file=f)" >> subtitles/build_ass.py

          DUR=$(cat audio/voice_duration.txt)
          python3 subtitles/build_ass.py "$DUR"

      # ---------- Render final ----------
      - name: Render final video with subs + VO
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p final_video
          Vdur=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 selected_media/merged.mp4)
          Adur=$(cat audio/voice_duration.txt)
          need_pad=$(awk -v v="$Vdur" -v a="$Adur" 'BEGIN{print (v+0 < a+1.0)?1:0}')
          if [ "$need_pad" = "1" ]; then
            EXTRA=$(awk -v v="$Vdur" -v a="$Adur" 'BEGIN{d=a - v + 1.0; if (d<0) d=0; print d}')
            ffmpeg -nostdin -y -f lavfi -i "color=c=black:s=1080x1920:d=${EXTRA}" -r 30 -c:v libx264 -crf 18 -pix_fmt yuv420p -an selected_media/outro.mp4
            printf "file '%s'\n" "merged.mp4" > selected_media/full_list.txt
            printf "file '%s'\n" "outro.mp4" >> selected_media/full_list.txt
            ( cd selected_media && ffmpeg -nostdin -y -f concat -safe 0 -i full_list.txt -c copy merged.mp4 )
          fi

          ffmpeg -nostdin -y -i selected_media/merged.mp4 -i audio/voice.wav \
            -vf "subtitles=subtitles/captions.ass" \
            -map 0:v:0 -map 1:a:0 \
            -c:v libx264 -preset medium -crf 18 -pix_fmt yuv420p \
            -c:a aac -b:a 192k -shortest "final_video/${OUT_NAME}"

      - name: Upload artifact (final video)
        uses: actions/upload-artifact@v4
        with:
          name: final_video
          path: final_video/

      # ---------- Dropbox upload ----------
      - name: Upload to Dropbox
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts
          printf '%s\n' "import sys, json, os, pathlib" > scripts/dbx_utils.py
          printf '%s\n' "from urllib.request import Request, urlopen" >> scripts/dbx_utils.py
          printf '%s\n' "TOK=os.environ['DROPBOX_ACCESS_TOKEN']" >> scripts/dbx_utils.py
          printf '%s\n' "FILE=sys.argv[1]; REMOTE=sys.argv[2]" >> scripts/dbx_utils.py
          printf '%s\n' "import os" >> scripts/dbx_utils.py
          printf '%s\n' "size=os.path.getsize(FILE)" >> scripts/dbx_utils.py
          printf '%s\n' "def post(url, headers, data):" >> scripts/dbx_utils.py
          printf '%s\n' "    from urllib.request import Request, urlopen" >> scripts/dbx_utils.py
          printf '%s\n' "    req=Request(url, data=data, headers=headers, method='POST')" >> scripts/dbx_utils.py
          printf '%s\n' "    return urlopen(req).read()" >> scripts/dbx_utils.py
          printf '%s\n' "if size <= 150*1024*1024:" >> scripts/dbx_utils.py
          printf '%s\n' "    arg=json.dumps({'path':REMOTE,'mode':'add','autorename':True,'mute':False}).encode('utf-8')" >> scripts/dbx_utils.py
          printf '%s\n' "    body=open(FILE,'rb').read()" >> scripts/dbx_utils.py
          printf '%s\n' "    h={'Authorization':'Bearer '+TOK,'Dropbox-API-Arg':arg.decode(),'Content-Type':'application/octet-stream'}" >> scripts/dbx_utils.py
          printf '%s\n' "    post('https://content.dropboxapi.com/2/files/upload', h, body)" >> scripts/dbx_utils.py
          printf '%s\n' "else:" >> scripts/dbx_utils.py
          printf '%s\n' "    h={'Authorization':'Bearer '+TOK,'Content-Type':'application/octet-stream','Dropbox-API-Arg':'{\"close\": false}'}" >> scripts/dbx_utils.py
          printf '%s\n' "    sid=json.loads(post('https://content.dropboxapi.com/2/files/upload_session/start', h, b''))['session_id']" >> scripts/dbx_utils.py
          printf '%s\n' "    chunk=15*1024*1024; off=0" >> scripts/dbx_utils.py
          printf '%s\n' "    with open(FILE,'rb') as f:" >> scripts/dbx_utils.py
          printf '%s\n' "        while True:" >> scripts/dbx_utils.py
          printf '%s\n' "            buf=f.read(chunk)" >> scripts/dbx_utils.py
          printf '%s\n' "            if not buf: break" >> scripts/dbx_utils.py
          printf '%s\n' "            arg={'cursor':{'session_id':sid,'offset':off},'close':False}" >> scripts/dbx_utils.py
          printf '%s\n' "            h={'Authorization':'Bearer '+TOK,'Content-Type':'application/octet-stream','Dropbox-API-Arg':json.dumps(arg)}" >> scripts/dbx_utils.py
          printf '%s\n' "            post('https://content.dropboxapi.com/2/files/upload_session/append_v2', h, buf)" >> scripts/dbx_utils.py
          printf '%s\n' "            off+=len(buf)" >> scripts/dbx_utils.py
          printf '%s\n' "    commit={'cursor':{'session_id':sid,'offset':size},'commit':{'path':REMOTE,'mode':'add','autorename':True,'mute':False}}" >> scripts/dbx_utils.py
          printf '%s\n' "    h={'Authorization':'Bearer '+TOK,'Content-Type':'application/octet-stream','Dropbox-API-Arg':json.dumps(commit)}" >> scripts/dbx_utils.py
          printf '%s\n' "    post('https://content.dropboxapi.com/2/files/upload_session/finish', h, b'')" >> scripts/dbx_utils.py
          printf '%s\n' "body=json.dumps({'path':REMOTE,'settings':{'requested_visibility':'public'}}).encode('utf-8')" >> scripts/dbx_utils.py
          printf '%s\n' "h={'Authorization':'Bearer '+TOK,'Content-Type':'application/json'}" >> scripts/dbx_utils.py
          printf '%s\n' "import json" >> scripts/dbx_utils.py
          printf '%s\n' "try:" >> scripts/dbx_utils.py
          printf '%s\n' "    link=json.loads(post('https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings', h, body))['url']" >> scripts/dbx_utils.py
          printf '%s\n' "except Exception:" >> scripts/dbx_utils.py
          printf '%s\n' "    body=json.dumps({'path':REMOTE,'direct_only':True}).encode('utf-8')" >> scripts/dbx_utils.py
          printf '%s\n' "    link=json.loads(post('https://api.dropboxapi.com/2/sharing/list_shared_links', h, body))['links'][0]['url']" >> scripts/dbx_utils.py
          printf '%s\n' "print(link.replace('?dl=0','?dl=1'))" >> scripts/dbx_utils.py

          FILE="final_video/${OUT_NAME}"
          [ -s "$FILE" ] || (echo "Fichier vidéo introuvable"; exit 1)
          TS=$(date +"%Y%m%d_%H%M%S")
          REMOTE_DIR="/horror"
          REMOTE_PATH="${REMOTE_DIR}/${TS}_${OUT_NAME}"

          LINK=$(python3 scripts/dbx_utils.py "$FILE" "$REMOTE_PATH")
          mkdir -p final_video
          printf '%s\n' "$LINK" > final_video/dropbox_link.txt
          echo "Dropbox direct link: $LINK"

      - name: Upload artifact (Dropbox link)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dropbox_link
          path: final_video/dropbox_link.txt